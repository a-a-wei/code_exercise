# CPP STL 容器简单操作

## string

~~~cpp
//构造函数
string(int n, char c);    //使用n个字符c初始化
string(const char* s);    //使用字符串s初始化
string(const string& str); 

//string <=> int
int stoi(const string & str)//将串按十进制转换为int
 还有double型stod,float型stof,long long型stoll等。
std::to_string(a)//将内置数据类型转换为string
    
//大小写转换
int tolower(int ch);
int toupper(int ch);
char *strlwr（char *a）
char *strupr（char *a）
 
//赋值
string &operator=(const string &s);//把字符串s赋给当前字符串
string &assign(const char *s);//用c类型字符串s赋值
string &assign(const string &s);//把字符串s赋给当前字符串
string &assign(int n,char c);//用n个字符c赋值给当前字符串

//连接 +=、append、push_back 
string &operator+=(const string &s);//把字符串s连接到当前字符串的结尾
string &append(const char *s);            //把c类型字符串s连接到当前字符串结尾
string &append(const string &s);    //同operator+=()
string &append(int n,char c);        //在当前字符串结尾添加n个字符c

//子串 substr
string substr(int pos = 0,int n = len) const;//返回pos开始的n个字符组成的字符串
//使用匿名构造函数返回子串：
string (iterator begin,iterator end)		//返回[begin,end);
string (&s[i],&s[j])					//返回	字符数组[i,j);
    
//交换 swap
void swap(string &s2);    //交换当前字符串与s2的值

//查找 find/rfind...
int find( {str or char}, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置
//查找成功时返回所在位置，失败返回string::npos的值或 -1；
 int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置

string &insert(int pos,const string &s);
iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置
string &erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串
s.pop_back()  //删除末尾一个字符
~~~

## math

~~~cpp
绝对值函数（abs，fabs，labs）
abs(x)	返回x的绝对值
double fabs(double x)		返回 x 的绝对值。
    
三角函数（cos，sin，tan）
double sin(double x) 		返回弧度角 x 的正弦。
    
反三角函数（acos，asin，atan）
double asin(double x) 		返回以弧度表示的 x 的反正弦。
    
指数和对数函数（exp，log，log10）
double exp(double x) 		返回 e 的 x 次幂的值。
double log(double x) 		返回 x 的自然对数（基数为 e 的对数）。
double log10(double x)		返回 x 的常用对数（基数为 10 的对数）。
    
幂指数和开方函数（pow，sqrt）
double pow(double x, double y)	返回 x 的 y 次幂。
double sqrt(double x)			返回 x 的平方根。
cbrt(x)	返回x的立方根

  
double modf(double x, double *integer)         返回值为小数部分（小数点后的部分），并设置 integer 为整数部分。
double fmod(double x, double y)   返回 x 除以 y 的余数。
double ceil(double x)           返回大于或等于 x 的最小的整数值。   
double floor(double x)            返回小于或等于 x 的最大的整数值。
~~~





## vector

`vector<vector<int> > `需要先分配大小

如：`vector<vector<int> > arr2d(m, vector<int>(n,0) );`

~~~cpp
定义迭代器   vector<int>::iterator iter;
构造函数
vector<T> v;             //采用模板实现类实现，默认构造函数
vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。
vector(n, elem=T() );           //构造函数将n个elem拷贝给本身。
vector(const vector &vec);    //拷贝构造函数。

empty();                            //判断容器是否为空
size();                              //返回容器中元素的个数
resize(int num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。
  				         //如果容器变短，则末尾超出容器长度的元素被删除
push_back(ele);                                  //尾部插入元素ele
pop_back();                                       //删除最后一个元素
insert(const_iterator pos, ele);        //迭代器指向位置pos插入元素ele
iterator erase(const_iterator pos);      //删除迭代器指向的元素,返回下一个元素迭代器
clear();                                            //删除容器中所有元素
at(int idx);          //返回索引idx所指的数据
operator[];           //返回索引idx所指的数据
front();              //返回容器中第一个数据元素
back();               //返回容器中最后一个数据元素
reserve(int len);  //容器预留len个元素长度，预留位置不初始化，元素不可访问。减少vector在动态扩展容量时的扩展次数
~~~

**deque** 接口与vector相同，支持随机访问，**可以较高效的在前、后，插、删。**

一般用作 **Queue**， **Stack**。

迭代时删除元素：

```cpp
for(auto it = arr.begin();it!=arr.end();){
    if( (*it) 满足删除条件 ){
        it = arr.erase(it);
    }else{
        it++;
    }
}
```



## heap

~~~cpp
Algorithm中的堆操作函数
头文件#include <algorithm>,STL在<algorithm.h>中实现了对存储在可随机访问容器(数组，vector，deque)中的元素进行堆操作的函数，包括make_heap, pop_heap, push_heap, sort_heap
相关参数：
_First, _Last：可以随机访问的迭代器/ 指针 _Comp: 比较函数（仿函数）,默认less<T>()  大顶堆
建立堆
make_heap(_First, _Last, _Comp) 默认是建立大顶堆的。
在堆中添加元素
push_heap(_First, _Last，_Comp)
要先在底层容器（数组或vector）里加入数据，再调用push_heap()。
实现细节：（1）添加元素到vector的尾部；（2）重新调整堆。
该算法必须是在满足堆序的条件下，添加元素。
如，插入15到当前的大顶堆里，vector容器名字为max_heap：
max_heap.push_back(15);
push_heap(max_heap.begin(), max_heap.end())
在堆中删除元素
pop_heap(_First, _Last，_Comp)
实现细节：（1）交换堆顶元素和末尾元素（2）堆size-1，重新调整堆。
注意算法执行完毕后，最大的元素并没有被取走，而是放于底层容器的末尾。如果要取走，则可以使用底部容器（vector）提供的pop_back()函数。
pop_heap()操作后，再调用max_heap.pop_back()，从底层容器中删掉原堆顶元素。
pop_heap(max_heap.begin(), max_heap.end());//取出了堆顶元素（也叫删除堆顶元素），放到了底层容器的末尾，原来末尾的元素替代堆顶，end迭代器减1，重新siftdown了堆
max_heap.pop_back();//从底层容器（数组或vector）中删除了元素
堆排序
sort_heap(_First, _Last，_Comp)
对堆进行堆排序
注意：这个排序是在一个堆上进行的。
    
//示例
vector<Node> testHeap(20);
// 建堆，默认大顶堆less<T>();
// make_heap(testHeap.begin(), testHeap.end(),cmp1());
make_heap(testHeap.begin(), testHeap.end(),cmp);
//先在容器中尾插元素，再调整
testHeap.push_back({100,99});
push_heap(testHeap.begin(),testHeap.end(),cmp);
//交换堆顶元素和末尾元素,再调整
pop_heap(testHeap.begin(),testHeap.end(),cmp);
testHeap.pop_back()

~~~

~~~cpp
priority_queue做堆
empty() 　　   如果队列为空，则返回真
pop()　　　　删除对顶元素，删除第一个元素
push() 　　     加入一个元素
size() 　　　  返回优先队列中拥有的元素个数
top() 　　　　返回优先队列对顶元素，返回优先队列中有最高优先级的元素
在默认的优先队列中，优先级高的先出队。（大顶堆）

头文件：
#include <queue>
声明方式：
1、普通方法：
priority_queue<int> q;  //默认大顶堆， 实现在 < 运算符， less<int>
priority_queue<int,vector<int>, greater<int> > q;  //小顶堆
2、自定义优先级：
//1.使用lambda表达式
auto comp = [](const int& lhs, const int& rhs) { return lhs > rhs; };
priority_queue<int, vector<int>, decltype(comp)> q(comp);

//2.使用结构体
struct cmp {     
　　bool operator()(int & x, int & y) {        
　　　　 return　x < y;　　 // 最大值优先 
　　}
};
priority_queue<int, vector<int>, cmp> q;    //定义方法
//其中，第二个参数为容器类型。第三个参数为比较函数。


//优先队列建堆
priority_queue<int> maxH;  //默认大顶堆  less<int>
vector<int> arr={1,2,3,4,5,6,7};
priority_queue<int> maxHeap(arr.begin(),arr.end());
priority_queue<Node,vector<Node>, cmp1 > minH;  //小顶堆

~~~

## list

双向循环链表    **插入操作和删除操作都不会造成原有list迭代器的失效，类似记录节点的地址** 这在vector,deque是不成立的。

可以用来模拟**stack** 和 **queue**

```cpp
构造
list<int> l1 = {1,2,3,4,5};
list<int> l2 {1,2,3,4,5};
list<int> l3 (10,2);
list<int> l4 (10);
list<int> l5 (l1.begin()++,l1.end()--);     //不能+或-固定值  !!!!! 因为链表无法所以索引

插入与删除
push_back(elem);//在容器尾部加入一个元素
pop_back();//删除容器中最后一个元素
push_front(elem);//在容器开头插入一个元素
pop_front();//从容器开头移除第一个元素
insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
iterator erase(const_iterator pos);      //删除迭代器指向的元素,返回下一个元素迭代器
remove(elem);//删除容器中所有与elem值匹配的元素。
list数据存取
front();        //返回第一个元素。
back();         //返回最后一个元素。
//迭代器不可以跳跃访问，即使是+1，只能++或--
```



## pair对组创建

map 可以直接用pair做key；set可以直接用pair作为元素；

其他自定义结构需要重载<

~~~cpp
pair<type, type> p ( value1, value2 );
pair<type, type> p = make_pair( value1, value2 );
pair<char,int> a= {'a',20}
~~~

## tuple元组

tuple对‘<’进行了重载，可以直接作为set<T>的元素；

头文件`#include <tuple>`

创建

~~~cpp
tuple<int, char> first;                             // 1)   first{}
tuple<int, char> second(first);                     // 2)   second{}
tuple<int, char> third(make_tuple(20, 'b'));   		// 3)   third{20,'b'}
tuple<long, char> fourth(third);                    // 4)的左值方式, fourth{20,'b'}
tuple<int, char> fifth(10, 'a');                    // 5)的右值方式, fifth{10.'a'}
tuple<int, char> sixth(make_pair(30, 'c'));    		// 6)的右值方式, sixth{30,''c}
auto first = std::make_tuple (10,'a');   			// tuple < int, char >
~~~

使用

```cpp
//计算 mytuple 存储元素的个数
size = tuple_size<decltype(mytuple)>::value;

//获得 mytuple 中存储的元素
auto& e0 = get<0>(mytuple);
//修改指定的元素
get<0>(mytuple) = 100;

//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替
tie(mystr, mydou, myint) = bar;
//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值
//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中
auto mycat = std::tuple_cat(mytuple, bar);
```

tuple 模板类对赋值运算符 = 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 ==、!=、<、>、>=、<= 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。

## unordered_map

hashmap, 平均O(1) ,读取时应记录下来，不应多次读取

如果要将自定义类型作为unordered_map的键值，需如下两个步骤：

- 定义哈希函数的函数对象；
- 定义等比函数的函数对象或者在自定义类里重载operator==()。

~~~cpp
template < class Key,                        //键值对中键的类型
           class T,                          //键值对中值的类型
           class Hash = hash<Key>,           //容器内部存储键值对所用的哈希函数
           class Pred = equal_to<Key>,       //判断各个键值对键相同的规则
           class Alloc = allocator< pair<const Key,T> >  // 指定分配器对象的类型
           > class unordered_map;
//自定义类型需要定制 hash<key> ,重载== 或 定制cmp对象


//函数对象是可以以函数方式与()结合使用的任意对象。这包括函数名、指向函数的指针和重载了“operator()”操作符的类对象
class Person{
public:
    string name;
    int age;

    Person(string n, int a){
        name = n;
        age = a;
    }
    
     bool operator==(const Person & p) const {
        return name == p.name && age == p.age;
    }
};

namespace std{
    template<>
    struct hash<Person>{//哈希的模板定制
    public:
        size_t operator()(const Person &p) const {
            return hash<string>()(p.name) ^ hash<int>()(p.age);
        }
    };
    
    template<>
    struct equal_to<Person>{//等比的模板定制
    public:
        bool operator()(const Person &p1, const Person &p2) const{
            return p1.name == p2.name && p1.age == p2.age;
        }
    };
}
//equal_to 可以用重载 == 代替
//unordered_map<Person, int> mp;    //用模板定制可以直接像内置数据类型那样使用


//重载operator()的类
struct hash_name{
	size_t operator()(const Person & p) const{
		return hash<string>()(p.name) ^ hash<int>()(p.age);
	}
};
//unordered_map<Person, int, hash_name> mp; 
~~~

常用方法

~~~cpp
size()	返回当前容器中存有键值对的个数。
count(key)	在容器中查找以 key 键的键值对的个数。可以用来判断容器中是否装有 (key,value) 
find(key)   在容器中查找以 key 键的键值对，找到返回迭代器，未找到返回 end();
operator[key]		重载了[]运算符，以key取值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。
void  insert(elem); //在容器中插入元素。m.insert(pair<int, int>(1, 10));
pair<iterator,bool>  emplace(键，值) //在容器中添加一个元素，等同 m[键]=值；
erase(key)	删除指定k-v
iterator erase(const_iterator pos);      //删除迭代器指向的元素,返回下一个元素迭代器
clear() 	清空容器，即删除容器中存储的所有键值对。
~~~



## unordered_set

~~~cpp
size()	返回当前容器中存有键值对的个数。
count(key)	在容器中查找以 key 值的个数。0或1
iterator find(key)   在容器中查找以 key 值，找到返回迭代器，未找到返回 end();
void insert()	向容器中添加新元素。
pair<iterator,bool>  empalce(args...)
erase(val)	删除指定值
iterator erase(const_iterator pos);      //删除迭代器指向的元素,返回下一个元素迭代器
clear() 	清空容器，即删除容器中存储的所有键值对。
~~~

## bitset

~~~cpp
#include <bitset>
using std::bitset;

//构造
bitset<n> b;	b 有 n 位，每位为 0
bitset<n> b(u);	b 是 unsigned long 型 u 的一个副本
bitset<n> b(s);	b 是 string 对象 s 中含有的位串的副本

    
//操作	
b.any()			//b 中是存在为1的二进制位
b.none()		//b 中二进制位是否全为0
b.count()		//b 中为1的二进制位的个数
b.size()		//b 中二进制位的个数
b[pos]			//访问 b 中位置为 pos 的二进制位
b.test(pos)		//b 中位置为 pos 的二进制位是否为 1
b.set()			//把 b 中所有二进制位置为 1
b.set(pos)		//b 中位置为 pos 的二进制位是设为 1
b.reset()		//把 b 中所有二进制位置为 0
b.reset(pos)	//b 中位置为 pos 的二进制位是设为 0
b.flip()		//把 b 中所有二进制位逐位反转
b.flip(pos)		//把 b 中位置为 pos 的二进制位反转
b.to_ulong()	//用 b 中同样的二进制位返回一个 unsigned long 值

bitset <N> & operator &= (const bitset <N> & rhs);  //和另一个 bitset 对象进行与操作
bitset <N> & operator |= (const bitset <N> & rhs);  //和另一个 bitset 对象进行或操作
bitset <N> & operator ^= (const bitset <N> & rhs);  //和另一个 bitset 对象进行异或操作
bitset <N> & operator <<= (size_t num);  //左移 num 位
bitset <N> & operator >>= (size_t num);  //右移 num 位

bitset <N> operator << (size_t pos) const;  //返回左移 pos 位后的结果
bitset <N> operator >> (size_t pos) const;  //返回右移 pos 位后的结果
bitset <N> operator ~ ();  //返回取反后的结果
bitset <N> operator & (const bitset <N> & rhs) const;  //返回和另一个 bitset 对象 rhs 进行与运算的结果
bitset <N> operator | (const bitset <N> & rhs) const;  //返回和另一个 bitset 对象 rhs 进行或运算的结果
bitset <N> operator ^ (const bitset <N> & rhs) const;  //返回和另一个 bitset 对象 rhs 进行异或运算的结果
~~~



## 算法

~~~cpp
__gcd(m,n) //最大公约数
max({...}) //最大值 max(a,b); max({a,b,c});
swap(a,b);//交换a和b

_FIter max_element<_FIter>(_ForwardIterator __first, _ForwardIterator __last)
//Return the maximum element in a range.

iterator find(iterator beg, iterator end, value);
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代end（）

头文件注意是 numeric
函数原型：
•	accumulate(iterator beg, iterator end, value);
// 计算容器元素累计总和
//value: sum起始值，为0；


Iterator lower_bound (first, last, const T& val); 在指定范围内查找 大于等于 目标值的第一个元素
定义在<algorithm>头文件中,其中，first 和 last 都为正向迭代器，[first, last) 用于指定函数的作用范围；val 用于指定目标元素；当查找成功时，迭代器指向找到的元素；如果查找失败，迭代器的指向和 last 迭代器相同。
upper_bound() 函数，用于在指定范围内查找 大于 目标值的第一个元素。

//统计自定义数据类型时候，需要配合重载 operator==
函数原型：
•	count(iterator beg, iterator end, value);

//按条件统计元素个数
函数原型：
•	count_if(iterator beg, iterator end, Predicate);
   
// 指定范围内的元素随机调整次序
•	random_shuffle(iterator beg, iterator end);


•	reverse(iterator beg, iterator end);
// 反转指定范围的元素

•	sort(iterator beg, iterator end, BiPredicate);
// BiPredicate 谓词 两个参数，返回bool值

void  fill(iterator beg, iterator end, value);
// 向容器中填充元素

•	generate(iterator beg, iterator end, Supplier);
// 向容器中填充元素
// Supplier 函数名或者函数对象的实例 无参，返回值填充进容器

//•	目标容器记得提前开辟空间
//函数原型：
•	copy(iterator beg, iterator end, iterator dest);
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
// beg 开始迭代器
// end 结束迭代器
// dest 目标起始迭代器


//•	搬运的目标容器必须要提前开辟空间，否则无法正常搬运
//函数原型：
void transform(iterator beg1, iterator end1, iterator beg2, _func);
//beg1 源容器开始迭代器
//end1 源容器结束迭代器
//beg2 目标容器开始迭代器
//_func 函数名或者函数对象的实例  传入第一个容器的参数，返回值填充进第二个容器

void for_each(iterator beg, iterator end, Consumer);
// 遍历算法 遍历容器元素
// beg 开始迭代器
// end 结束迭代器
// Consumer 函数名或者函数对象的实例   一个参数无返回
                         
                         
功能描述：
•	两个容器元素合并，并存储到另一容器中
•	目标容器需要提前开辟空间
函数原型：
•	merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
// 容器元素合并，并存储到另一容器中
// 注意: 两个容器必须是有序的
// beg1 容器1开始迭代器         // end1 容器1结束迭代器 
// beg2 容器2开始迭代器         // end2 容器2结束迭代器 
// dest 目标容器开始迭代器


//全排列：next_permutation(start, start+size);
vector<int> arr = {1,2,3,4,5};
do{
    //something...
}while(next_permutation(arr.begin(), arr.end()))
                                            
                                            

求两个容器的交集
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
// 求两个集合的交集
// 注意:两个集合必须是有序序列，//取两个里面较小的值给目标容器开辟空间
//set_intersection返回值既是交集中最后一个元素的位置
//beg1,beg2可以是排好序的vector，也可以是set
//dest是预先分配好空间的vector
/* s
vector<int> res(v1.size()+v2.size());
auto it = set_union(v1.begin(),v1.end(),v2.begin(),v2.end(),res.begin());
res.resize(it-res.begin());
*/
求两个集合的并集
set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
// 求两个集合的并集
// 注意:两个集合必须是有序序列	//取两个容器的和给目标容器开辟空间


求两个集合的差集
set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);

~~~

## 迭代器辅助函数

~~~cpp
//迭代器
vector<int>::iterator iter = vec.begin();

advance(it, n)	将 it 迭代器前进 n 个位置。(n为负数时后退 |n| 个位置)
distance(first, last)	计算 first 和 last 之间的距离。
begin(cont)	cont 表示某个容器，该函数可以返回一个指向 cont 容器中第一个元素的迭代器。
end(cont)	cont 表示某个容器，该函数可以返回一个指向 cont 容器中最后一个元素之后位置的迭代器。
prev(it)	it 为指定的迭代器，该函数默认可以返回一个指向上一个位置处的迭代器。注意，it 至少为双向迭代器。
next(it)	it 为指定的迭代器，该函数默认可以返回一个指向下一个位置处的迭代器。注意，it 最少为前向迭代器。

~~~





# Java 容器操作技巧

| 优先级 | 运算符                                           | 结合性       |
| :----- | :----------------------------------------------- | ------------ |
| 1      | ()、[]、{}                                       | 从左向右     |
| 2      | !、+、-、~、++、--                               | 从右向左     |
| 3      | *、/、%                                          | 从左向右     |
| 4      | +、-                                             | 从左向右     |
| 5      | «、»、>>>                                        | 从左向右     |
| 6      | <、<=、>、>=、instanceof                         | 从左向右     |
| **7**  | **==、!=**                                       | **从左向右** |
| **8**  | **&**                                            | **从左向右** |
| 9      | ^                                                | 从左向右     |
| 10     | \|                                               | 从左向右     |
| 11     | &&                                               | 从左向右     |
| 12     | \|\|                                             | 从左向右     |
| 13     | ?:                                               | 从右向左     |
| 14     | =、+=、-=、*=、/=、&=、\|=、^=、~=、«=、»=、>>>= | 从右向左     |

## Scanner

~~~java
boolean hasNext​() 如果此扫描仪在其输入中有另一个令牌，则返回true。  
boolean hasNextInt​() 如果此扫描仪输入中的下一个标记可以使用 nextInt()方法将其解释为默认基数中的int值，则返回true。  
String next​() 查找并返回此扫描仪的下一个完整令牌。  
int nextInt​() 将输入的下一个标记扫描为 int 。  
String nextLine​() 将此扫描仪推进到当前行并返回跳过的输入。 
~~~



## StringBulider

~~~java
//String
String​(byte[] bytes, int offset, int length) 通过使用平台的默认字符集解码指定的字节子阵列来构造新的 String 。  
static String valueOf(Object obj) 返回 Object参数的字符串表示形式。  
char[] toCharArray() 将此字符串转换为新的字符数组。  
String[] split(String regex) 将此字符串拆分为给定的 regular expression的匹配。  
static String format(String format, Object... args) 
String (StringBuilder builder) 分配一个新的字符串，其中包含当前包含在字符串构建器参数中的字符序列。  
String replace​(char oldChar, char newChar) 返回从替换所有出现的导致一个字符串 oldChar ，在这个字符串 newChar 。  
String replace​(CharSequence target, CharSequence replacement) 将与字面目标序列匹配的字符串的每个子字符串替换为指定的文字替换序列。  
String toUpperCase() 
String toLowerCase() 

    
//StringBuilder
StringBuilder (String str) 构造一个初始化为指定字符串内容的字符串构建器。  
StringBuilder append(Object obj) 追加 Object参数的字符串表示形式。    
StringBuilder append(char[] str) 将 char数组参数的字符串表示追加到此序列。  
StringBuilder append(char[] str, int offset, int len) 

char charAt(int index) 返回指定索引处的此序列中的 char值。  
void setCharAt(int index, char ch) 指定索引处的字符设置为 ch 。
    
StringBuilder delete(int start, int end) 删除此序列的子字符串中的字符。  
StringBuilder deleteCharAt(int index) 在此序列中的指定位置移除 char 。  

int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。没有找到返回-1；
int indexOf(String str, int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。 
int lastIndexOf(String str) 返回指定子字符串最后一次出现的字符串中的索引。  
    
StringBuilder insert(int offset, Object obj) 将 Object参数的字符串表示插入到此字符序列中。 

StringBuilder reverse() 导致该字符序列被序列的相反代替。   
String substring(int start) 返回一个新的 String ，其中包含此字符序列中当前包含的字符的子序列。  
String substring(int start, int end) 
String toString() 返回表示此顺序中的数据的字符串。  
public void setLength​(int newLength)
    
void ensureCapacity(int minimumCapacity)
void trimToSize()
~~~



## Math

~~~java
static int abs(int a) 返回一个 int绝对值。  //有 double、float、long版本
static double ceil(double a)  上取整
static double floor(double a) 下取整
static double rint(double a) 最接近取整。  
static double log(double a) 返回 double值的自然对数（基数 e ）。  
static int max(int a, int b) 返回两个 int中的较大值。  //有 double、float、long版本
static int min(int a, int b) 返回两个 int中的较小值。  
static double pow(double a, double b) 将第一个参数的值返回到第二个参数的幂。  
static double random() 返回值为 double的正值，大于等于 0.0 ，小于 1.0    
static double sin​(double a) 返回角度的三角正弦。  a - 以弧度表示的角度。
static double toDegrees​(double angrad) 将以弧度测量的角度转换为以度为单位的近似等效角度。 
~~~

## Arrays

~~~java
static <T> List<T> asList​(T... a) 返回由指定数组支持的固定大小的列表。  
static String toString​(Object[] a) 返回指定数组的内容的字符串表示形式。  
static int binarySearch​(int[] a, int key) 使用二叉搜索算法搜索指定的int数组的指定值。 
static int compare​(int[] a, int[] b) int字典顺序比较两个 int阵列。  

static int[] copyOf​(int[] original, int newLength) 复制指定的数组，使用零截断或填充（如有必要），以使副本具有指定的长度。  

static boolean equals​(int[] a, int[] a2) 如果两个指定的int数组彼此 相等 ，则返回 true  

static void fill​(int[] a, int val) 将指定的int值分配给指定的int数组的每个元素。  
static void fill​(int[] a, int fromIndex, int toIndex, int val) 将指定的int值分配给指定的int数组的指定范围的每个元素。  
    
static void Arrays.setAll(arr,(idx)-> (int)(Math.random()*100) );

static void sort​(int[] a) 按照数字顺序排列指定的数组。  
static void sort​(int[] a, int fromIndex, int toIndex) 按升序排列数组的指定范围。  

static <T> void sort​(T[] a, Comparator<? super T> c) 根据指定的比较器引发的顺序对指定的对象数组进行排序。  
~~~



## Collections

~~~java
static <T> boolean addAll​(Collection<? super T> c, T... elements) 将所有指定的元素添加到指定的集合。  
static <T> int binarySearch​(List<? extends T> list, T key, Comparator<? super T> c) 使用二叉搜索算法搜索指定对象的指定列表。  
static <T> void fill​(List<? super T> list, T obj) 用指定的元素替换指定列表的所有元素。  
static T max​(Collection<? extends T> coll) 根据其元素的 自然顺序返回给定集合的最大元素。 
static void reverse​(List<?> list) 反转指定列表中元素的顺序。 
static void rotate​(List<?> list, int distance) 将指定列表中的元素后移distance，前移(-dis)
static void shuffle​(List<?> list) 使用默认的随机源随机排列指定的列表。  
static <T> void sort​(List<T> list, Comparator<? super T> c) 根据指定的比较器引起的顺序对指定的列表进行排序。 
static void swap​(List<?> list, int i, int j) 交换指定列表中指定位置的元素。  
~~~



## LinkedList

~~~java
LinkedList() 构造一个空列表。  
LinkedList(Collection<? extends E> c) 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。  

int size() 返回此列表中的元素数。  

void addFirst(E e) 在该列表开头插入指定的元素。  
void addLast(E e) 将指定的元素追加到此列表的末尾。  

E getFirst() 返回此列表中的第一个元素。  
E getLast() 返回此列表中的最后一个元素。  

int indexOf(Object o) 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。  
int lastIndexOf(Object o) 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。 

E remove(int index) 删除该列表中指定位置的元素。  
boolean remove(Object o) 从列表中删除指定元素的第一个出现（如果存在）。 
boolean removeIf(Predicate<? super E> filter)
E removeFirst() 从此列表中删除并返回第一个元素。  
E removeLast() 从此列表中删除并返回最后一个元素。  

void clear() 从列表中删除所有元素。 

boolean contains(Object o) 如果此列表包含指定的元素，则返回 true 。  

<T> T[] toArray(T[] a) 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。  
~~~

## ArrayList

~~~java
void ensureCapacity​(int minCapacity) 确保它至少能够容纳最小容量参数指定的元素数量。  
ListIterator<E> listIterator​(int index) 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。  
void add​(int index, E element) 在此列表中的指定位置插入指定的元素。  
boolean add​(E e) 将指定的元素追加到此列表的末尾。  
E get​(int index) 返回此列表中指定位置的元素。  
E remove​(int index) 删除该列表中指定位置的元素。  
boolean removeIf(Predicate<? super E> filter)
E set​(int index, E element) 用指定的元素替换此列表中指定位置的元素。 
void trimToSize​() 修改这个 ArrayList实例的容量是列表的当前大小。  
~~~

## ArrayDeque

ArrayDeque不是线程安全的。 
ArrayDeque**不可以存取null元素**，因为系统根据某个位置是否为null来判断元素的存在。 
当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。

~~~java
1.添加元素
    addFirst(E e)在数组前面添加元素
    addLast(E e)在数组后面添加元素
    offerFirst(E e) 在数组前面添加元素，并返回是否添加成功
    offerLast(E e) 在数组后天添加元素，并返回是否添加成功

2.删除元素
    removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常
    pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null
	removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常
    pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null
    removeFirstOccurrence(Object o) 删除第一次出现的指定元素
    removeLastOccurrence(Object o) 删除最后一次出现的指定元素

3.获取元素
    getFirst() 获取第一个元素,如果没有将抛出异常
    getLast() 获取最后一个元素，如果没有将抛出异常

4.队列操作
    add(E e) 在队列尾部添加一个元素
    offer(E e) 在队列尾部添加一个元素，并返回是否成功
    remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())
    poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())
    element() 获取第一个元素，如果没有将抛出异常
    peek() 获取第一个元素，如果返回null


5.栈操作
    push(E e) 栈顶添加一个元素 (addFirst);
    pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常
    peek() 栈顶元素。

6.其他
    size() 获取队列中元素个数
    isEmpty() 判断队列是否为空
    iterator() 迭代器，从前向后迭代
    descendingIterator() 迭代器，从后向前迭代
    contain(Object o) 判断队列中是否存在该元素
    toArray(T[] a) 转成数组
    clear() 清空队列
    clone() 克隆(复制)一个新的队列
~~~

## PriorityQueue

1. add 和 offer 的区别在于达到上限时 add 抛出异常，offer 返回 false；
2. remove 和 poll 的区别在于，队列为空时前者抛出异常，后者返回空；
3. element 和 peek 都返回队列头部元素，但是前者失败抛出异常，后者返回空。

~~~java
PriorityQueue(int initialCapacity)
PriorityQueue(Comparator<? super E> comparator) 创建具有默认初始容量的 PriorityQueue ，并根据指定的比较器对其元素进行排序。   默认小顶堆(a,b)->a-b ;  大顶堆：(a,b)->b-a  ;

boolean offer(E e) 将指定的元素插入到此优先级队列中。
E peek() 检索但不删除此队列的头，如果此队列为空，则返回 null 。  
E poll() 检索并删除此队列的头部，如果此队列为空，则返回 null 。 

add() //增加一个元索如果队列已满，则抛出一个IIIegaISlabEepeplian异常
remove() //移除并返回队列头部的元素如果队列为空，则抛出一个NoSuchElementException.异常
element() //列头部的元素如果队列为空，则抛出一个NoSuchElementException.异常

boolean contains(Object o) 如果此队列包含指定的元素，则返回 true 。  
Iterator<E> iterator() 返回此队列中的元素的迭代器。  
void clear() //从此优先级队列中删除所有元素。  
int size() 返回此集合中的元素数。  
<T> T[] toArray(T[] a) 返回一个包含此队列中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类 
~~~

## HashMap

~~~java
boolean containsKey​(Object key) 如果此映射包含指定键的映射，则返回 true 。  
boolean containsValue​(Object value) 如果此映射将一个或多个键映射到指定的值，则返回 true 。  

V get​(Object key) 返回指定键映射到的值，如果此映射不包含键的映射，则返回 null 。  
V getOrDefault​(Object key, V defaultValue) 返回指定键映射到的值，如果此映射不包含该键的																映射，则返回 defaultValue  
V put​(K key, V value) 将指定的值与此映射中的指定键相关联。 
V putIfAbsent​(K key, V value) 如果指定的键尚未与值相关联（或映射到 null ）将其与给定值相关联并返回 null ，否则返回当前值。  

Set<K> keySet​() 返回此地图中包含的键的Set视图。
Set<Map.Entry<K,V>> entrySet​() 返回此地图中包含的映射的Set视图。 
Collection<V> values​() 返回此地图中包含的值的Collection视图。 

int size​() 返回此地图中键值映射的数量。  
boolean isEmpty​() 如果此映射不包含键值映射，则返回 true 。  
  
V remove​(Object key) 从该地图中删除指定键的映射（如果存在）。 
void clear​() 从这张地图中删除所有的映射。
    
//遍历
for(Map.Entry<Long, String> entry : map.entrySet()){
	Long id = entry.getKey();
 	String name = entry.getValue();
 
}
~~~

## HashSet

~~~java
boolean add​(E e) 将指定的元素添加到此集合（如果尚未存在）。  
void clear​() 从此集合中删除所有元素。  

boolean contains​(Object o) 如果此集合包含指定的元素，则返回 true 。  
boolean isEmpty​() 如果此集合不包含元素，则返回 true 。  

Iterator<E> iterator​() 返回此集合中元素的迭代器。  
boolean remove​(Object o) 如果存在，则从该集合中删除指定的元素。  
boolean removeIf(Predicate<? super E> filter)
int size​() 返回此集合中的元素数（其基数）。  
~~~

HashSet自定义元素需要同时重写equeals和hashCode方法

hashCode()：对象在散列表中的位置

quals()：对象是否重复(相等覆盖，不相等追加)

~~~java
class Pair{
    public int first,second;
    public Pair(int a,int b){
        this.first = a;
        this.second = b;
    }

    @Override
    public int hashCode() {
        return Objects.hash(first,second);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Pair p = (Pair)o;
        return first == p.first && second == p.second;
    } 
}
~~~

TreeSet专属接口

~~~
first() 如果TreeSet不为空，则此方法返回集合中的第一个元素。否则，它会抛出NoSuchElementException。
last() 如果集合不为空，此方法将返回最后一个元素：
subSet(from, to) 此方法将返回从from到to的元素。 [from, to)
~~~



TreeSet自定义元素需实现Comparable接口或提供Comparator给TreeSet构造器

~~~java
//提供Comparator给TreeSet构造器
class Pair implements Comparable<Pair>{
    public int first,second;
    public Pair(int a,int b){
        this.first = a;
        this.second = b;
    }
}

var set = new TreeSet<Pair>((a,b)->{
            if(a.first != b.first)return a.first-b.first;
            else return a.second -b.second;
        });

//自定义元素需实现Comparable接口
class Pair implements Comparable<Pair>{
    public int first,second;
    public Pair(int a,int b){
        this.first = a;
        this.second = b;
    }
    @Override
    public int compareTo(Pair o) {
        return this.first != o.first?this.first-o.first:this.second-o.second;
    }
}
var set = new TreeSet<Pair>();
~~~



# Python 容器

Python3 的六个标准数据类型中：

- **不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；
- **可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。

## 数字(Number)类型

python中数字有四种类型：整数、布尔型、浮点数和复数。

- **int** (整数), 如 1, 只有一种整数类型 int，表示为长整型， 没有限制大小 
- **bool** (布尔), 如 True。 *bool 是 int 的子类，* 
- **float** (浮点数), 如 1.23、3E-2
- **complex** (复数), 如 1 + 2j、 1.1 + 2.2j

***Python 数字类型转换***

有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。

- **int(x)** 将x转换为一个整数。
- **float(x)** 将x转换到一个浮点数。
- **complex(x)** 将x转换到一个复数，实数部分为 x，虚数部分为 0。
- **complex(x, y)** 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。



注意：**

- 1、Python可以同时为多个变量赋值，如a, b = 1, 2。
- 2、一个变量可以通过赋值指向不同类型的对象。
- 3、数值的除法包含两个运算符：**/** 返回一个浮点数，**//** 返回一个整数。
- 4、在混合计算时，Python会把整型转换成为浮点数。

[`fractions`](https://docs.python.org/zh-cn/3.10/library/fractions.html#module-fractions) 模块支持分数运算。

~~~python
from fractions import Fraction
>>> Fraction(16, -10)
Fraction(-8, 5)
>>> Fraction(123)
Fraction(123, 1)
>>> Fraction()
Fraction(0, 1)
>>> Fraction('3/7')
Fraction(3, 7)
~~~





## 字符串(String)

- Python 中单引号 **'** 和双引号 **"** 使用完全相同。
- 使用三引号(**'''** 或 **"""**)可以指定一个多行字符串。
- 转义符 **\\**。
- 字符串前表示符: r 不转义；f格式化；b字节串；
- 按字面意义级联字符串，如 **"this " "is " "string"** 会被自动转换为**“ this is string “ **。
- 字符串可以用 **+** 运算符连接在一起，用 ***** 运算符重复。
- Python 中的字符串有两种索引方式，从左往右以 **0** 开始，从右往左以 **-1** 开始。
- Python 中的字符串不能改变。
- Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。
- 字符串的截取的语法格式如下：**变量[start:stop:步长]**       **[start,stop)  左闭右开 **

***str和ascci码转换***

**ord**函数（order）返回一个字符对应的unicode编码，

**chr**函数（char）正好反过来，它返回一个unicode编码对应的字符。

***字符列表 <-> 字符串***

~~~python
''.join(['a','b','c'])
list(str)
~~~

 

***字符串格式化***

```python
#①使用与 C 中 sprintf 函数一样的语法。 ①
s = "我叫 %s 今年 %d 岁!" % ('小明', 10) 


'''② str.format()
format 函数可以接受不限个参数，位置可以不按顺序。
'''

"{} {}".format("hello", "world")    # 不设置指定位置，按默认顺序   'hello world'
 
"{0} {1}".format("hello", "world")  # 设置指定位置    'hello world'
 
"{1} {0} {1}".format("hello", "world")  # 设置指定位置    'world hello world'

"网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com")
 
# 通过字典设置参数
site = {"name": "菜鸟教程", "url": "www.runoob.com"}
print("网站名：{name}, 地址 {url}".format(**site))
 
# 通过列表索引设置参数
my_list = ['菜鸟教程', 'www.runoob.com']
print("网站名：{0[0]}, 地址 {0[1]}".format(my_list))  # "0" 是必须的

#③f-string
f'Hello {name}'  # 替换变量
f'{1+2}'         # 使用表达式
```

***字符串常用内建函数如下***

```python
str.find(sub[, start[, end]])
返回子字符串 sub 在 s[start:end) 切片内被找到的最小索引。 如果 sub 未被找到则返回 -1。
要检查 sub 是否为子字符串，请使用 in 操作符:

str.replace(old, new[, count])
返回字符串的副本，其中出现的所有子字符串 old 都将被替换为 new。 如果给出了可选参数 count，则只替换前 count 次出现。
str.split(sep=None, maxsplit=- 1)
返回一个由字符串内单词组成的列表，使用 sep 作为分隔字符串。默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。 如果给出了 maxsplit，则最多进行 maxsplit 次拆分（因此，列表最多会有 maxsplit+1 个元素）。
    
str.count(sub[, start[, end]])
返回子字符串 sub 在 [start, end] 范围内非重叠出现的次数。 可选参数 start 与 end 会被解读为切片
    
str.capitalize()
返回原字符串的副本，其首个字符大写，其余为小写。
str.casefold()
返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。
str.isalnum()
如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 True
str.isalpha()
如果字符串中的所有字符都是字母，并且至少有一个字符，返回 True
str.isdigit()
如果字符串中的所有字符都是数字，并且至少有一个字符，返回 True
str.islower()
如果字符串中至少有一个区分大小写的字符且此类字符均为小写则返回 True
str.isupper()
如果字符串中至少有一个区分大小写的字符且此类字符均为大写则返回 True
str.isspace()
如果字符串中只有空白字符且至少有一个字符则返回 True 
str.lower()
返回原字符串的副本，其所有区分大小写的字符均转换为小写。
str.upper()
返回原字符串的副本，其中所有区分大小写的字符均转换为大写


str.startswith(prefix[, start[, end]])
如果字符串以指定的 prefix 开始则返回 True，否则返回 False
str.endswith(suffix[, start[, end]])
如果字符串以指定的 suffix 结束返回 True，否则返回 False
str.removeprefix(prefix, /)
如果字符串以 prefix 字符串开头，返回 string[len(prefix):] 。否则，返回原始字符串的副本：
str.removesuffix(suffix, /)
如果字符串以suffix字符串结尾，并且非空，返回 string[:-len(suffix)] 。否则，返回原始字符串的副本：

str.format(*args, **kwargs)
str.format_map(mapping)
类似于 str.format(**mapping)，不同之处在于 mapping 会被直接使用而不是复制到一个 dict。 适宜使用此方法的一个例子是当 mapping 为 dict 的子类的情况：
str.encode(encoding='utf-8', errors='strict')
返回原字符串编码为字节串对象的版本。 默认编码为 'utf-8'。

'分隔字符串'.join(iterabal) 讲可迭代序列中的元素(必须是str，不是可用map(str,it)映射)拼接起来
```

***字节串***

字节串（bytes）和字符串（string）的对比：

- 字符串由若干个字符组成，以**字符**为单位进行操作；字节串由若干个字节组成，以**字节**为单位进行操作。
- 字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。
- 字节串和字符串都是不可变序列，不能随意增加和删除数据。


bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。

```python
在python中 str是以Unicode方式编码的
bytes.decode("gbk") =>str    将一个字节串以gbk解码成str
str.encode("utf-8")	=>bytes   将str以utf-8编码成字节串
```





## List（列表）

List（列表） 是 Python 中使用最频繁的数据类型。

列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。

列表是写在方括号 **[]** 之间、用逗号分隔开的元素列表。

和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。

列表截取的语法格式如下：

```
变量[头下标:尾下标]
```

索引值以 **0** 为开始值，**-1** 为从末尾的开始位置。

```python
len(list)		列表元素个数
max(list)		返回列表元素最大值
min(list)		返回列表元素最小值
list(seq)		将元组转换为列表

成员方法：
list.append(obj)	在列表末尾添加新的对象
list.count(obj)		统计某个元素在列表中出现的次数
list.extend(seq)	在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）l1 + l2
list.index(obj)		从列表中找出某个值第一个匹配项的索引位置
list.insert(index, obj)		将对象插入列表
list.pop([index=-1])	移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
list.remove(obj)		移除列表中某个值的第一个匹配项
list.reverse()		反向列表中元素
list.sort( key=None, reverse=False)		对原列表进行排序
# key = lambda ele : -ele, 按照key函数返回值排序， key： (元素)->值
list.clear()		清空列表
list.copy()		复制列表
```



## Tuple（元组）

元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 **()** 里，元素之间用逗号隔开。

元组中的元素类型也可以不相同：

构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：

```python
tup1 = ()    # 空元组
tup2 = (20,) # 一个元素，需要在元素后添加逗号
tup3 = 20 ,  #可以不用括号
```

string、list 和 tuple 都属于 sequence（序列）。

## Set（集合）

集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。

基本功能是进行成员关系测试和删除重复元素。

可以使用大括号 **{ }** 或者 **set()** 函数创建集合，注意：创建一个**空集合必须用 set()** 而不是 **{ }**，因为 **{ }** 是用来创建一个空字典。

创建格式：

```
parame = {value01,value02,...}
或者
set(value)
```

```python
a - b                              # 差集
a | b                              # 并集
a & b                              # 交集
a ^ b                              # 不同时包含于a和b的元素

add()	为集合添加元素
clear()	移除集合中的所有元素
copy()	拷贝一个集合
difference()	返回多个集合的差集
difference_update()	移除集合中的元素，该元素在指定的集合也存在。
discard()	删除集合中指定的元素
intersection()	返回集合的交集
intersection_update()	返回集合的交集。
isdisjoint()	判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。
issubset()	判断指定集合是否为该方法参数集合的子集。
issuperset()	判断该方法的参数集合是否为指定集合的子集
pop()	随机移除元素
remove()	移除指定元素
symmetric_difference()	返回两个集合中不重复的元素集合。
symmetric_difference_update()	移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。
union()	返回两个集合的并集
update()	给集合添加元素
```



## Dictionary（字典）

字典（dictionary）是Python中另一个非常有用的内置数据类型。

列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。

字典是一种映射类型，字典用 **{ }** 标识，它是一个无序的 **键(key) : 值(value)** 的集合。

键(key)必须使用不可变类型。

在同一个字典中，键(key)必须是唯一的。

**{x: x\**2 for x in (2, 4, 6)}** 该代码使用的是字典推导式，更多推导式内容可以参考：[Python 推导式](https://www.runoob.com/python3/python-comprehensions.html)。

另外，字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。

~~~python
# 字典迭代
for k, v in mapping.items():
    pass

for k in mapping.keys(): 
    val = mapping[k]
~~~



**注意：**

- 1、字典是一种映射类型，它的元素是键值对。
- 2、字典的关键字必须为不可变类型，且不能重复。
- 3、创建空字典使用 **{ }**。

````python
list(d)
返回字典 d 中使用的所有键的列表。

len(d)
返回字典 d 中的项数。

d[key]
返回 d 中以 key 为键的项。 如果映射中不存在 key 则会引发 KeyError。

d[key] = value
将 d[key] 设为 value。

del d[key]
将 d[key] 从 d 中移除。 如果映射中不存在 key 则会引发 KeyError。

key in d
如果 d 中存在键 key 则返回 True，否则返回 False。

key not in d
等价于 not key in d。

iter(d)
返回以字典的键为元素的迭代器。 这是 iter(d.keys()) 的快捷方式。

clear()
移除字典中的所有元素。

copy()
返回原字典的浅拷贝。

classmethod fromkeys(iterable[, value])
使用来自 iterable 的键创建一个新字典，并将键值设为 value。

fromkeys() 是一个返回新字典的类方法。 value 默认为 None。 所有值都只引用一个单独的实例，因此让 value 成为一个可变对象例如空列表通常是没有意义的。 要获取不同的值，请改用 字典推导式。

get(key[, default])
如果 key 存在于字典中则返回 key 的值，否则返回 default。 如果 default 未给出则默认为 None，因而此方法绝不会引发 KeyError。

items()
返回由字典项 ((键, 值) 对) 组成的一个新视图。

keys()
返回由字典键组成的一个新视图。

values()
返回由字典值组成的一个新视图。

pop(key[, default])
如果 key 存在于字典中则将其移除并返回其值，否则返回 default。 如果 default 未给出且 key 不存在于字典中，则会引发 KeyError。

popitem()
从字典中移除并返回一个 (键, 值) 对。 键值对会按 LIFO 的顺序被返回。

popitem() 适用于对字典进行消耗性的迭代，这在集合算法中经常被使用。 如果字典为空，调用 popitem() 将引发 KeyError。

reversed(d)
返回一个逆序获取字典键的迭代器。 这是 reversed(d.keys()) 的快捷方式。

setdefault(key[, default])
如果字典存在键 key ，返回它的值。如果不存在，插入值为 default 的键 key ，并返回 default 。 default 默认为 None。

update([other])
使用来自 other 的键/值对更新字典，覆盖原有的键。 返回 None。

update() 接受另一个字典对象，或者一个包含键/值对（以长度为二的元组或其他可迭代对象表示）的可迭代对象。 如果给出了关键字参数，则会以其所指定的键/值对更新字典: d.update(red=1, blue=2)。
````



*class* collections.**defaultdict**(*default_factory=None*, */*[, *...*])

返回一个新的默认值字典。 [`defaultdict`](https://docs.python.org/zh-cn/3/library/collections.html#collections.defaultdict) 是内置 [`dict`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict) 类的子类。 

本对象包含一个名为 [`default_factory`](https://docs.python.org/zh-cn/3/library/collections.html#collections.defaultdict.default_factory) 的属性，构造时，第一个参数用于为该属性提供初始值，默认为 `None`。所有其他参数（包括关键字参数）都相当于传递给 [`dict`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict) 的构造函数。

~~~python
mp = collections.defaultdict(lambda: 0)
# mp = collections.defaultdict(int)   #int()函数返回0
print(mp['a'], mp['dd'])
~~~



*class* collections.**Counter**([*iterable-or-mapping*])

一个 [`Counter`](https://docs.python.org/zh-cn/3/library/collections.html?highlight=counter#collections.Counter) 是一个 [`dict`](https://docs.python.org/zh-cn/3/library/stdtypes.html#dict) 的子类，用于计数可哈希对象。它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。计数可以是任何整数值，包括0和负数。 [`Counter`](https://docs.python.org/zh-cn/3/library/collections.html?highlight=counter#collections.Counter) 类有点像其他语言中的 bags或multisets。

元素从一个 *iterable* 被计数或从其他的 *mapping* (or counter)初始化：

```python
>>> c = Counter()                           # a new, empty counter
>>> c = Counter('gallahad')                 # a new counter from an iterable
>>> c = Counter({'red': 4, 'blue': 2})      # a new counter from a mapping
>>> c = Counter(cats=4, dogs=8)             # a new counter from keyword args
```

Counter对象有一个字典接口，如果引用的键没有任何记录，就返回一个0，而不是弹出一个 [`KeyError`](https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError) :

设置一个计数为0不会从计数器中移去一个元素。使用 `del` 来删除它:

```python
>>> c['sausage'] = 0                        # counter entry with a zero count
>>> del c['sausage']                        # del actually removes the entry
```



## collections.deque

*class* collections.**deque**([*iterable*[, *maxlen*]])

返回一个新的双向队列对象，从左到右初始化(用方法 [`append()`](https://docs.python.org/zh-cn/3/library/collections.html#collections.deque.append)) ，从 *iterable* （迭代对象) 数据创建。如果 *iterable* 没有指定，新队列为空。

如果 *maxlen* 没有指定或者是 `None` ，deques 可以增长到任意长度。否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出

~~~python
append(x)   #添加 x 到右端。

appendleft(x)    #添加 x 到左端。

pop()	#移去并且返回一个元素，deque 最右侧的那一个。 如果没有元素的话，就引发一个 IndexError。

popleft()	#移去并且返回一个元素，deque 最左侧的那一个。 如果没有元素的话，就引发 IndexError。

dp[0]  # 第一个元素

dp[-1]  # 最后一个元素

clear()      #移除所有元素，使其长度为0.

copy()		#创建一份浅拷贝。

count(x)	#计算 deque 中元素等于 x 的个数。

extend(iterable)	#扩展deque的右侧，通过添加iterable参数中的元素。

extendleft(iterable)	#扩展deque的左侧，通过添加iterable参数中的元素。在结果中iterable参数中的顺序将被反过来添加。

index(x[, start[, stop]])
返回 x 在 deque 中的位置（在索引 start 之后，索引 stop 之前）。 返回第一个匹配项，如果未找到则引发 ValueError。


insert(i, x)	#在位置 i 插入 x 。
如果插入会导致一个限长 deque 超出长度 maxlen 的话，就引发一个 IndexError。

remove(value)	#移除找到的第一个 value。 如果没有的话就引发 ValueError。

reverse()	#将deque逆序排列。返回 None 。

rotate(n=1)	#向右循环移动 n 步。 如果 n 是负数，就向左循环。

如果deque不是空的，向右循环移动一步就等价于 d.appendleft(d.pop()) ， 向左循环一步就等价于 d.append(d.popleft()) 。

Deque对象同样提供了一个只读属性:
maxlen
Deque的最大尺寸，如果没有限定的话就是 None 。
~~~

deque 还支持迭代、封存、`len(d)`、`reversed(d)`、`copy.copy(d)`、`copy.deepcopy(d)`、成员检测运算符 [`in`](https://docs.python.org/zh-cn/3/reference/expressions.html#in) 以及下标引用例如通过 `d[0]` 访问首个元素等。 索引访问在两端的复杂度均为 O(1) 但在中间则会低至 O(n)。

## 内置函数

~~~python
format()：格式化输出函数(在控制输出精度和空格补齐等问题中很好用)
round(x，保留位数=0)：四舍五入
abs(x)：绝对值
len()：返回对象的长度，如列表、字典等
range(start=0, stop, step=1])：返回一个可迭代对象，常用于for循环
sum(iterable)/max()/min()： 求和函数/最大值/最小值
pow(x, y, [z])：求幂函数x**y, 运算完毕可以顺带对z取模；大数取模问题可以直接AC
sorted(iterable, key, reverse)：采用Timsort的稳定排序算法，默认升序；
reversed(iterabal):反转一个序列
isinstance(obj, type)：判断类型
all(iterable)/any(iterable)：迭代与操作/迭代或操作（0、1、None均等价于False)
int(x, base=10))/float()/str()：转整数(可自定义进制)/转浮点数/转字符串
bin()/oct()/hex()：10进制转二进制(返回0b开头的字符串)/10进制转八进制(返回0开头的字符串)/10进制转十六进制(返回0x开头的字符串)
ord()/chr()：字符转ASCII或ASCII转字符
complex(real, imag)：创建一个复数，不过现在可以直接通过语法糖创建，eg：1+2j
divmod()：返回一个包含商和余数的元组(a // b, a % b)
eval(expression, [globals, locals])：执行一个字符串表达式，并返回表达式的值，  eg：eval('pow(2, 2)')= 4 =4=4；
map(function, iterable...)：映射函数，需要注意的是在Python3中返回一个迭代对象而不再是一个列表
filter(function, iterable)：过滤函数
reduce(function, iterable, [initializer])：累积函数，现在被归类到functools模块中
zip(iterable, ...)：将对象中对应的元素打包成一个个元组，常用于并联取值，详见下文的【注意事项】
hash(obj)：返回哈希码，常用于对象比较或将其转化为唯一的索引(不过更推荐使用id()完成该需求)
id()：返回对象的唯一标识符，和hash()类似，但更鲁棒更快且可以对list、def等对象求id
enumerate()：将一个可遍历的数据对象组合为一个(idx,val)序列，eg:for i, v in enumerate(list_a):
print(*objects, sep=' ', end='\n') 标准输出函数
input() 函数接受一个标准输入数据，返回为 string 类型。 
~~~



修改递归迭代深度

~~~python
# 在开头加上
import sys # python 默认递归深度不超过1000，做dfs会比C吃亏
sys.setrecursionlimit(10000000)# 手动修改深度
~~~

## 常用模块

***数学函数*** math模块

| 函数                                                         | 返回值 ( 描述 )                                              |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [abs(x)](https://www.runoob.com/python3/python3-func-number-abs.html) | 返回数字的绝对值，如abs(-10) 返回 10                         |
| [ceil(x)](https://www.runoob.com/python3/python3-func-number-ceil.html) | 返回数字的上入整数，如math.ceil(4.1) 返回 5                  |
| [exp(x)](https://www.runoob.com/python3/python3-func-number-exp.html) | 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045         |
| [fabs(x)](https://www.runoob.com/python3/python3-func-number-fabs.html) | 返回数字的绝对值，如math.fabs(-10) 返回10.0                  |
| [floor(x)](https://www.runoob.com/python3/python3-func-number-floor.html) | 返回数字的下舍整数，如math.floor(4.9)返回 4                  |
| [log(x)](https://www.runoob.com/python3/python3-func-number-log.html) | 如math.log(math.e)返回1.0,math.log(100,10)返回2.0            |
| [log10(x)](https://www.runoob.com/python3/python3-func-number-log10.html) | 返回以10为基数的x的对数，如math.log10(100)返回 2.0           |
| [max(x1, x2,...)](https://www.runoob.com/python3/python3-func-number-max.html) | 返回给定参数的最大值，参数可以为序列。                       |
| [min(x1, x2,...)](https://www.runoob.com/python3/python3-func-number-min.html) | 返回给定参数的最小值，参数可以为序列。                       |
| [modf(x)](https://www.runoob.com/python3/python3-func-number-modf.html) | 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 |
| [pow(x, y)](https://www.runoob.com/python3/python3-func-number-pow.html) | x**y 运算后的值。                                            |
| [round(x [,n\])](https://www.runoob.com/python3/python3-func-number-round.html) | 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。**其实准确的说是保留值将保留到离上一位更近的一端。** |
| [sqrt(x)](https://www.runoob.com/python3/python3-func-number-sqrt.html) | 返回数字x的平方根。                                          |
| gcd(a,b)                                                     | 最大公因数， 最小公倍数 lcm=  a*b//gcd(a,b)                  |

***随机数函数***

Python包含以下常用随机数函数：random模块

| 函数                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [choice(seq)](https://www.runoob.com/python3/python3-func-number-choice.html) | 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 |
| [randrange ([start,\] stop [,step])](https://www.runoob.com/python3/python3-func-number-randrange.html) | 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 |
| [random()](https://www.runoob.com/python3/python3-func-number-random.html) | 随机生成下一个实数，它在[0,1)范围内。                        |
| seed([x])                                                    | 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 |
| [shuffle(lst)](https://www.runoob.com/python3/python3-func-number-shuffle.html) | 将序列的所有元素随机排序                                     |
| [uniform(x, y)](https://www.runoob.com/python3/python3-func-number-uniform.html) | 随机生成下一个实数，它在[x,y]范围内。                        |

***二分查询算法***

bisect模块，时间复杂度O ( n ) = l o g n ,常用于有序序列(升序)的插入和查找。

~~~python
bisect.bisect_left(a, x, lo=0, hi=len(a), *, key=None)
在 a 中找到 x 合适的插入点以维持有序。参数 lo 和 hi 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 x 已经在 a 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 a 是列表（list）的话，返回值是可以被放在 list.insert() 的第一个参数的。

返回的插入点 i 将数组 a 分成两半，<x, i, >=x


bisect.bisect_right(a, x, lo=0, hi=len(a), *, key=None)
bisect.bisect(a, x, lo=0, hi=len(a), *, key=None)
类似于 bisect_left()，但是返回的插入点是 a 中已存在元素 x 的右侧。

返回的插入点 i 将数组 a 分成两半， <= x,  i,  > x 

~~~



***堆***

heapq模块，构建小顶堆。构建时直接传入一个列表作为堆结构，调用heapify等函数时会直接改变这个堆列表的内部顺序。

小顶堆：根节点的值小于等于其左右节点的值，即a[k] <= a[2*k+1] and a[k] <= a[2*k+2]

自定义结构要重载<运算符

~~~python
class Node:
    def __init__(self,x)
    	self.x = x
    def __lt__(self,other)->bool:
        return self.x < other.x
~~~

~~~python
heapify(heap)：构建/调整一个堆
heappop(heap)：返回最小数
heappush(heap, item)：向堆内压入一个元素
heappushpop(heap, item)：向堆内压入一个元素后返回最小数
heapreplace(heap, item)：删除堆中最小元素并加入一个元素
merge(*iterables)：合并多个有序列表，并返回有序列表的迭代器(即需要手动list())
nlargest(n, iterable, key)：返回最大的n个数的列表
nsmallest(n, iterable, key)：返回最小的n个数的列表
~~~

***functools***

这个库里有很多高阶函数，包括前面介绍到的`cmp_to_key` 以及 `reduce`，但是比较逆天的有 `lru_cache`

主要方法：

- `@lru_cache(maxsize=128, typed=False)`：LRU缓存，在递归和DP中取`maxsize=None`用作记忆法进行剪枝。
- `@cache` 加在递归函数上用作记忆化搜索
- `reduce(function, iterable, [initializer])`：累积函数，常用于列表连续求积

***[`itertools`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#module-itertools)高效循环***

**无穷迭代器：**

| 迭代器                                                       | 实参          | 结果                                  | 示例                                    |
| :----------------------------------------------------------- | :------------ | :------------------------------------ | :-------------------------------------- |
| [`count()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.count) | start, [step] | start, start+step, start+2*step, ...  | `count(10) --> 10 11 12 13 14 ...`      |
| [`cycle()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.cycle) | p             | p0, p1, ... plast, p0, p1, ...        | `cycle('ABCD') --> A B C D A B C D ...` |
| [`repeat()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.repeat) | elem [,n]     | elem, elem, elem, ... 重复无限次或n次 | `repeat(10, 3) --> 10 10 10`            |

**根据最短输入序列长度停止的迭代器：**

| 迭代器                                                       | 实参                        | 结果                                             | 示例                                                       |
| :----------------------------------------------------------- | :-------------------------- | :----------------------------------------------- | :--------------------------------------------------------- |
| [`accumulate()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.accumulate) | p [,func]                   | p0, p0+p1, p0+p1+p2, ...                         | `accumulate([1,2,3,4,5]) --> 1 3 6 10 15`                  |
| [`chain()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.chain) | p, q, ...                   | p0, p1, ... plast, q0, q1, ...                   | `chain('ABC', 'DEF') --> A B C D E F`                      |
| [`chain.from_iterable()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.chain.from_iterable) | iterable -- 可迭代对象      | p0, p1, ... plast, q0, q1, ...                   | `chain.from_iterable(['ABC', 'DEF']) --> A B C D E F`      |
| [`compress()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.compress) | data, selectors             | (d[0] if s[0]), (d[1] if s[1]), ...              | `compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F`            |
| [`dropwhile()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.dropwhile) | pred, seq                   | seq[n], seq[n+1], ... 从pred首次真值测试失败开始 | `dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1`          |
| [`filterfalse()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.filterfalse) | pred, seq                   | seq中pred(x)为假值的元素，x是seq中的元素。       | `filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8`      |
| [`groupby()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.groupby) | iterable[, key]             | 根据key(v)值分组的迭代器                         |                                                            |
| [`islice()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.islice) | seq, [start,] stop [, step] | seq[start:stop:step]中的元素                     | `islice('ABCDEFG', 2, None) --> C D E F G`                 |
| [`pairwise()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.pairwise) | iterable -- 可迭代对象      | (p[0], p[1]), (p[1], p[2])                       | `pairwise('ABCDEFG') --> AB BC CD DE EF FG`                |
| [`starmap()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.starmap) | func, seq                   | func(*seq[0]), func(*seq[1]), ...                | `starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000`       |
| [`takewhile()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.takewhile) | pred, seq                   | seq[0], seq[1], ..., 直到pred真值测试失败        | `takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4`            |
| [`tee()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.tee) | it, n                       | it1, it2, ... itn 将一个迭代器拆分为n个迭代器    |                                                            |
| [`zip_longest()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.zip_longest) | p, q, ...                   | (p[0], q[0]), (p[1], q[1]), ...                  | `zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-` |

**排列组合迭代器：**

| 迭代器                                                       | 实参                 | 结果                                  |
| :----------------------------------------------------------- | :------------------- | :------------------------------------ |
| [`product()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.product) | p, q, ... [repeat=1] | 笛卡尔积，相当于嵌套的for循环         |
| [`permutations()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.permutations) | p[, r]               | 长度r元组，所有可能的排列，无重复元素 |
| [`combinations()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.combinations) | p, r                 | 长度r元组，有序，无重复元素           |
| [`combinations_with_replacement()`](https://docs.python.org/zh-cn/3/library/itertools.html?highlight=groupby#itertools.combinations_with_replacement) | p, r                 | 长度r元组，有序，元素可重复           |

| 例子                                       | 结果                                              |
| :----------------------------------------- | :------------------------------------------------ |
| `product('ABCD', repeat=2)`                | `AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD` |
| `permutations('ABCD', 2)`                  | `AB AC AD BA BC BD CA CB CD DA DB DC`             |
| `combinations('ABCD', 2)`                  | `AB AC AD BC BD CD`                               |
| `combinations_with_replacement('ABCD', 2)` | `AA AB AC AD BB BC BD CC CD DD`                   |

# 操作技巧

## 位操作

~~~
&
|
^
~
~~~

**ascii**

~~~
'0' -- 48
'A' -- 65
'a' -- 97
~~~



*1*. 利用或操作 | 和空格将英文字符**转换为小写**

```cpp
('a' | ' ') = 'a'
('A' | ' ') = 'a'
```

*2*. 利用与操作 & 和下划线将英文字符**转换为大写**

```cpp
('b' & '_') = 'B'
('B' & '_') = 'B'
```

*3*. 利用异或操作 ^ 和空格进行英文字符**大小写互换**

```cpp
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'
```

*4*. 判断两个整数是否异号

```cpp
int x = -1, y = 2;
bool f = ((x ^ y) < 0); // true

int x = 3, y = 2;
bool f = ((x ^ y) < 0); // false
```

*5*. 交换两个数 a!=b

```cpp
int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b;
// 现在 a = 2, b = 1
```



对二进制数 位操作

~~~
把第 i 位 置1：		a |= (1 << i)
把第 i 位 置0：		a &= ~(1 << i)
把第 i 位 取反：	   a ^= (1 << i)
读取第 i 位 的值：	  ( (a >> i) & 1)

x & (−x) 将 x 的二进制表示中的最低位的 1保留，其它全为0(可以获得 x 的二进制表示中的最低位的 1 的位置)；
(补码表示：即将原数取反加一，即最低位1不变，前面的取反，后面的为0);

x & (x−1) 可以将 x 的二进制表示中的最低位的 1 置成 0。


「二进制枚举子集」的技巧。
枚举子集相当于二进制减法的压缩版本，比如 10101 -> 10100 -> 10001 -> 10000 -> 00101 -> ...
这里给出对应的步骤：
记该数为 x。我们用 sub 表示当前枚举到的子集。初始时sub=x，因为 x也是本身的子集；
我们不断地令 sub=(sub−1) & x，其中 & 表示按位与运算。这样我们就可以从大到小枚举 x 的所有子集。当 sub=0 时枚举结束。
~~~

~~~cpp
//计算x二进制中1的个数
int bitCount(int x){
	int count=0;
	while(x){
		count++;
		x &= x-1;//将x的最低位1置零
	}
	return count;
}

//保留奇数位
x & 0xaa_aa_aa_aa    //1010 1010 ...
    
//保留偶数位
x & 0x55_55_55_55   //0101 0101
~~~

## 环型数组

计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可以模拟出环形数组的效果，一般是通过 % 运算符求模（余数），获得环形特效：



```cpp
int[] arr = {1,2,3,4,5};
int n = arr.length, index = 0;
while (true) {
    print(arr[index % n]);
    index++;
}
```

![tmp4C36](MD_IMG/%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.assets/tmp4C36.png)



## 递归Debug

**我的建议是直接在递归函数内部打印关键值，配合缩进，直观地观察递归函数执行情况**。

最能提升我们 debug 效率的是缩进，除了解法函数，我们新定义一个函数 `printIndent` 和一个全局变量 `count`：

~~~cpp
void printIndent(int n) {
    for (int i = 0; i < n; i++) {
        printf("   ");
    }
}
~~~



**在递归函数的开头，调用 `printIndent(count++)` 并打印关键变量；然后在所有 `return` 语句之前调用 `printIndent(--count)` 并打印返回值**。



## 扫描线

**安排会议室：相交区间的最大个数**

[会议室2](https://www.lintcode.com/problem/919/)

给你输入若干形如 `[begin, end]` 的区间，代表若干会议的开始时间和结束时间，请你计算至少需要申请多少间会议室。

换句话说，**如果把每个会议的起始时间看做一个线段区间，那么题目就是让你求最多有几个重叠区间**，

我们首先把这些会议的时间区间进行投影：现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到会议开始的点，计数器 `count` 加一，每遇到会议结束的点，计数器 `count` 减一：

**这样一来，每个时刻有多少个会议在同时进行，就是计数器 `count` 的值，`count` 的最大值，就是需要申请的会议室数量**。

~~~cpp
def min_meeting_rooms(self, intervals: List[Interval]) -> int:
    line = []
    for itv in intervals:
        line.append((itv.start,1))
        line.append((itv.end,-1))
    line.sort()
    maxNum = 0
    i = 0
    count = 0
    while i<len(line):
		#从前往后扫描， 每次扫描值相等的点，开始点count+1，结束的count-1；
        val = line[i][0]
        while i<len(line) and line[i][0]==val:
            count += line[i][1]
            i+=1
        maxNum = max(maxNum, count)
    return maxNum
~~~



2 用小顶堆管理会议室：

按照 开始时间 对会议进行排序。

用小顶堆存储正在进行会议的结束时间，则堆顶就是所有正在进行会议的最早结束时间。

当开始一个新会议时，将新会议开始时间和堆顶最早结束时间比较，

晚的话，就将堆顶弹出，并存入新会议的结束时间。

早的话，就新开一个会议室，将新会议的结束时间存入堆。

最后堆的元素个数就是所需的最小会议室。



[850. 矩形面积 II - 力扣（LeetCode）](https://leetcode.cn/problems/rectangle-area-ii/submissions/)

题目： 给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle[i] = [x1, y1, x2, y2]，左下角坐标，右下角坐标计算平面中所有 rectangles 所覆盖的总面积 。

解：

先将所有的y坐标排序，去重后，最多2n个点，2n-1个**纵向区间seg**，

将所有的x坐标（附带该矩形的下标，用于找该矩形的上下界；标签tag：左边+1，右边-1）排序；

从小到大扫描x坐标，

​		将相等的的点作为一组，

​				xLong = 下一个不想等的x点 - point[x];

​				对于某个点，将它所在矩形的上下界包含的纵向区间seg[i]  +tag;

​		yLong = 0;

​		检查所有的seg，大于零则 yLong +=seg[i];

​		area +=xLong*yLong;



~~~cpp
int rectangleArea(vector<vector<int>>& rectangles) {
    long long MOD = 1e9+7;
    //横向扫描
    vector<vector<int> > horzScan(rectangles.size()*2,vector<int>(3,0));
    for(int i=0;i<rectangles.size();++i){
        auto & rect = rectangles[i];
        //记录左右边界的x坐标，左边标记1，右边标记-1；
        horzScan.push_back({rect[0],i,1});
        horzScan.push_back({rect[2],i,-1});
    }
    //横向 按 x坐标 升序排序
    sort(horzScan.begin(), horzScan.end(), [](auto& a,auto& b){
        return a[0]<b[0];
    });

    //纵向点 
    set<int> verticalPoints;
    for(auto & rect : rectangles){
        verticalPoints.insert(rect[1]);
        verticalPoints.insert(rect[3]);
    }
    vector<int> yPoints(verticalPoints.begin(),verticalPoints.end());
    //纵向区间
    vector<int>seg(yPoints.size()-1,0);

    long long ans =0;

    for(int i=0;i<horzScan.size();){
        auto & xPoint = horzScan[i];

        int j=i+1;
        //相等的点一起处理
        for(;j<horzScan.size();++j){
            if(horzScan[j][0] != xPoint[0])
                break;
        }
        //一个xPoint代表从当前点开始的一个区间，最后一个点之后没有区间，不用计算面积。
        if(j==horzScan.size())
            break;

        for(int k=i;k<j;k++){
            int rectIdx = horzScan[k][1];
            int tag = horzScan[k][2];
            int lower = rectangles[rectIdx][1];
            int upper = rectangles[rectIdx][3];

            //横向扫描，左边点时，将矩形包含的纵向区间标记seg[i]  +1, 右边点时标记 -1
            //seg[i]>0 时有效。
            for(int v = 0;v<seg.size();++v){
                if(lower<=yPoints[v] && yPoints[v+1]<=upper){
                    seg[v]+=tag;
                }
            }
        }

        long long scanArea = 0;
        for(int v=0;v<seg.size();++v){
            if(seg[v]>0){
                scanArea+=yPoints[v+1]-yPoints[v];
            }
        }
        ans += scanArea*(horzScan[j][0]-xPoint[0]);
        i=j;
    }
    return ans%MOD;
}
~~~

~~~cpp
struct Segtree {
    int cover;
    int length;
    int max_length;
};

class Solution {
    vector<Segtree> tree;
    vector<int> hbound;
public:
    int rectangleArea(vector<vector<int>>& rectangles) {
        int n = rectangles.size();
        for (const auto& rect: rectangles) {
            // 下边界
            hbound.push_back(rect[1]);
            // 上边界
            hbound.push_back(rect[3]);
        }
        sort(hbound.begin(), hbound.end());
        hbound.erase(unique(hbound.begin(), hbound.end()), hbound.end());
        int m = hbound.size();
        // 线段树有 m-1 个叶子节点，对应着 m-1 个会被完整覆盖的线段，需要开辟 ~4m 大小的空间
        tree.resize(m * 4 + 1);
        init(1, 1, m - 1);

        vector<tuple<int, int, int>> sweep;
        for (int i = 0; i < n; ++i) {
            // 左边界
            sweep.emplace_back(rectangles[i][0], i, 1);
            // 右边界
            sweep.emplace_back(rectangles[i][2], i, -1);
        }
        sort(sweep.begin(), sweep.end());

        long long ans = 0;
        for (int i = 0; i < sweep.size(); ++i) {
            int j = i;
            while (j + 1 < sweep.size() && get<0>(sweep[i]) == get<0>(sweep[j + 1])) {
                ++j;
            }
            if (j + 1 == sweep.size()) {
                break;
            }
            // 一次性地处理掉一批横坐标相同的左右边界
            for (int k = i; k <= j; ++k) {
                auto&& [_, idx, diff] = sweep[k];
                // 使用二分查找得到完整覆盖的线段的编号范围
                int left = lower_bound(hbound.begin(), hbound.end(), rectangles[idx][1]) - hbound.begin() + 1;
                int right = lower_bound(hbound.begin(), hbound.end(), rectangles[idx][3]) - hbound.begin();
                update(1, 1, m - 1, left, right, diff);
            }
            ans += static_cast<long long>(tree[1].length) * (get<0>(sweep[j + 1]) - get<0>(sweep[j]));
            i = j;
        }
        return ans % static_cast<int>(1e9 + 7);
    }

    void init(int idx, int l, int r) {
        tree[idx].cover = tree[idx].length = 0;
        if (l == r) {
            tree[idx].max_length = hbound[l] - hbound[l - 1];
            return;
        }
        int mid = (l + r) / 2;
        init(idx * 2, l, mid);
        init(idx * 2 + 1, mid + 1, r);
        tree[idx].max_length = tree[idx * 2].max_length + tree[idx * 2 + 1].max_length;
    }

    void update(int idx, int l, int r, int ul, int ur, int diff) {
        if (l > ur || r < ul) {
            return;
        }
        if (ul <= l && r <= ur) {
            tree[idx].cover += diff;
            pushup(idx, l, r);
            return;
        }
        int mid = (l + r) / 2;
        update(idx * 2, l, mid, ul, ur, diff);
        update(idx * 2 + 1, mid + 1, r, ul, ur, diff);
        pushup(idx, l, r);
    }

    void pushup(int idx, int l, int r) {
        if (tree[idx].cover > 0) {
            tree[idx].length = tree[idx].max_length;
        }
        else if (l == r) {
            tree[idx].length = 0;
        }
        else {
            tree[idx].length = tree[idx * 2].length + tree[idx * 2 + 1].length;
        }
    }

};

~~~

